
<html>
<h2>Current Projects:</h2>

Qt for Google Native Client

<p>

<a href="http://msorvig.github.io/qt-quick-web-runtime-bin/index.html">The Qt Quick Web Runtime</a>
<a href="https://github.com/msorvig/qt-quick-web-runtime">(source)</a>

<br>

<a href="http://msorvig.github.io/qt-quick-playground/index.html">The Qt Quick Playground</a>
<a href="https://github.com/msorvig/qt-quick-playground">(source)</a>

<h2>Post Morten</h2>
<p>

Many software research projects end up in the great virtual desk drawer once
interst is lost/the key techincal issues has been solved/a 
general lack of practical utility has been demonstrated. 

<p>

I'm documenting some of my projects here, as a record
for myself and others that might be intersted. Reach
me at msorvig at gmail.com.

<br><br>

<b>Current</b><br>
<a href="#GitStats">Git Project History Statistics</a><br>

<b>Past</b><br>
<a href="#QWebClient">QWebClient</a>

<a name="GitStats"><h3>Git Project History Statistics</h3></a>

Created by parsing the output of "git log", running that through SQL, and then vizualizing with jqPlot.
<p>

Commits are counted against the first branch they appear in. Patch size is not accounted for. The branch
names are from the perspective of today - Qt 4.7 was of course developet in the "master" branch at some
point but is charted as "4.7".

<iframe src="qt-history.html" width = 100% height = 350 frameborder='0'></iframe><br>
<iframe src="qtcreator-history.html" width = 100% height = 350 frameborder='0'> </iframe><br>

<a name="QWebClient"><h3>QWebClient</h3></a>

QWebClient was a thin client for Qt programs, implemented in pure 
javascript that ran in any modern[2009] browser. No plugins were
required.

<br><br>

Blog: <a href = http://labs.qt.nokia.com/2009/09/18/qt-in-the-cloud-with-qwebclient/> qt-in-the-cloud-with-qwebclient </a>

<br><br>
Source code: <a href = http://qt.gitorious.org/qt-labs/webclient/> qt.gitorious.org/qt-labs/webclient/ </a>
<br><br>

<img src=webclient.png>

<br><br>	

Technical highligts includes duplicating Qt's widget hiearachy with
DOM nodes, and representing each widget with an image or a real DOM
node of the correct type (ex. QLineEdit -> &lt;input type=text&gt;). Event
handling was implemented via long polling: dual XmlHttpRequests were
made to a QTcpSocket-based event dispatcher on the server. One
request/socket was always kept open on the server, allowing it to push
events to the client.
 
 <br><br>
 
Main issues were performance (lots of image data going out) and subtle
text layout issues. Layout metrics was calcuted on the server, but 
the actual size of the rendered text on the client would often not
match.

 <br><br>

Trivia:
<ul>
<li> As an additional social hack an IFrame containg a live version of the chat
example was embedd in the Qt labs blog post, causing unsuspecting blog readers
to be thrown into an irc session. The server ran on an Amazon EC2 instance.
<li> All instances ran in one process, creating new windows on a headless Xvfb,
handling simultanious input from all users. I'm now surprised that Qt actaully
handled this.
<li> Hall-of-mirrors webkit-within-webkit was attempted with partial success.
<li> <a href = webclient-log.txt>Log</a> from the blog post chat session.
</ul>


<p>


</html>

